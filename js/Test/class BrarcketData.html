<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        #canvas-container {
		  position: absolute;
		  top: 0;
		  left: 0;
		  width: 100vw;
		  height: 100vh;
		  overflow: hidden;
		}

		#canvas {
		  width: 100%;
		  height: 100%;
		  image-rendering: pixelated;
		  margin: 0 auto;
		  max-width: 100vw;
		  max-height: 100vh;

		  object-fit: contain;
		  object-position: center;
		}
    </style>
    <title>Canvas Scaling</title>
</head>
<body>



<script>
	/*let
		textFunc = `function add(args) {return args[0] + args[1];}`;//"function add(args) {return args[0] + args[1];}";
	const addFunction = eval(textFunc);
	const result = addFunction([1, 2]);
	console.log(result);*/
	// Ваша строка с функцией
//const functionString = "function add(args) {return args[0] + args[1];}";

// Используем eval для выполнения строки кода
//const addFunction = eval(`(${functionString})`);

// Вызываем функцию
class BracketData {
  constructor(Text = "", Args = [], Commands = [], Type = "", Func = "", ArgsType = [], Value = 0) {
    this._Text = Text,
    this._Args = Args,
    this._Commands = Commands,
    this._Type = Type,
    this._Func = Func,
    this._ArgsType = ArgsType,
	  this._Value = Value;	
  }
  
  // Геттеры
  get Text() {
    return this._Text
  }

  get Args() {
    return this._Args
  }

  get Commands() {
    return this._Commands
  }

  get Type() {
    return this._Type
  }

  get Func() {
    return this._Func
  }

  get ArgsType() {
    return this._ArgsType
  }
  
  get Value(){
	return this._Value
  }

  // Сеттеры
  setText(Text) {
    this._Text = Text
  }

  setArgs(Args) {
    this._Args = Args
  }
  
  setCommands(Commands) {
    this._Commands = Commands
  }
  
  setType(Type) {
    this._Type = Type
  }

  setFunc(Func) {
    this._Func = Func
  }

  setArgsType(ArgsType) {
    this._ArgsType = ArgsType
  }
  
  setValue(Value){
    this._Value = Value
  }
  
  //add
  addArg(Arg){
    this._Args.push(Arg)
  } 

  addCommands(CommandsArray){
	this._Commands.push(CommandsArray)
  }  

  // Деструкторы
  deleteText() {
    this._Text = null
  }

  deleteArgs() {
    this._Args = null
  }

  deleteCommands() {
    this._Commands = null
  }

  deleteType() {
    this._Type = null
  }

  deleteFunc() {
    this._Func = null
  }

  deleteArgsType() {
    this._ArgsType = null
  }
  
  deleteValue(){
    this._Value = null
  }
}

function openAllBrackets(_text) {
  let 
		result = {
			text: "",
			args: [],
			commands: [],
			type: "" //str(str,var,float),func,funcCommands, commandsList
		},
		newCommandResult = [], //Array of commands
		typeBracket = {
			"(": "arg",
			"[": "array",
			"{": "command",
			//"\n": "newCommand"
		},
		text = _text,
		isCommandsText = false;

  main();
  return getType();

  //====

  function main(){
    for (;((text).length>0);) {
      let char = text[0];
      //debug? console.log(`text = ${text}`):"";
      
      switch (typeBracket[char] ?? "default") {
      
        case "arg":
          text = text.slice(1);
          caseArgBracket();
          break;
          
        case "command":
          text = text.slice(1);
          caseCommandBracket();
          break;
          
        case "array": //TODO: сделать работу с массивами
          break;
          
        /*case "newCommand":
          text = text.slice(1);
          caseNewCommandChar();
          break;*/
          
        case "default":
          result.text += char;
          text = text.slice(1);
          break;
          
      }
    }
  }
	
	function openCommandBracket(_text){
		let 
			result = [],
			text = _text,
			bracketsCount = 0,
			commandText = "",
			bracketCharDict = {
				"{": 1,
				"}": -1
			};
			
		function pushCommand(){
			commandText.trim().length>0?result.push(commandText):"";//проверка на пустое значение
			commandText=""
		}
		
		for (;(text.length>0);) {
			let char = text[0];
			
			bracketsCount += bracketCharDict[char] ?? 0;

			if ((char === "\n")&&(bracketsCount===0)){
				 pushCommand()
			} else {
				commandText+=char
			}
			text = text.slice(1)
		}
		
		pushCommand();
		
		return  result
	}
	
	function openTypeBrackets(_text, _charOpenBracket, _charClosedBracket){
		let 
			bracketCount = 1, 
			resultText = "",
			itText = false,
			text=_text;
			
		const bracketCharDict = {
			[_charOpenBracket]: 1,
			[_charClosedBracket]: -1
		}
		
		for (;(bracketCount > 0)&&(text.length>0);){
			let char = text[0];
			bracketCount += bracketCharDict[char] ?? 0;
			if (bracketCount===0) {break}
			resultText+=char;
			text = text.slice(1)
		}
		
		if (bracketCount >= 1) {
			debug?  console.warn(`\n[Warning] In opening the brackets of the text: "${_charOpenBracket+_text}"\nThe number of open and closed brackets does not match, ignoring char "${_charOpenBracket}"`) :"";
			itText = true
		}
		
		return {
			text: resultText, 
			itText: itText
		}
	};
		
	function caseArgBracket(){
		let 
			argResult =  openTypeBrackets(text,"(",")");
		
		if (argResult.itText){
			result.text += "(";
		} else {
			text = text.slice(argResult.text.length+1);
			let openedArg =  argResult.text; ///openAllBrackets();
			result.args.push(openedArg); //TODO: добавить условие для добавление аргумента (Проверка на пустое значение);
		}
	}
			
	function caseCommandBracket(){
		let 
			commandResult =  openTypeBrackets(text,"{","}");
				
		if (commandResult.itText){
			result.text += "{";
		} else {
			let commandsArray = [];
			
			text = text.slice(commandResult.text.length+1);
			let openedBrackets =  openCommandBracket(commandResult.text);
			
			for (let i = 0; i < openedBrackets.length; i++) {
				let command =  openedBrackets[i];
				commandsArray.push(command)
			}
			result.commands.push(commandsArray)
		}
	}
	
	function getType(){
		if ((result.commands).length){
			result.text = result.text.replace(/[\s\t\n]/g, "").toLowerCase();
			return {
				text: result.text,
				args: result.args.map ((element) => {
					return JSON.stringify(openAllBrackets(element));
				}),
				commands: result.commands.map ((commandsArrayElement) => {
					return commandsArrayElement.map((command) => {
						//console.log(command);
						return JSON.stringify(openAllBrackets(command))
					})
				}),
				type: "fyncCommands"
			}
		} else if ((result.args).length){
			result.text = result.text.replace(/[\s\t\n]/g, "").toLowerCase();			
			/*if(!result.text.length){
				result = (result.args[0])
				return  result.type;
			}*/
			return {
				arg_type: 0,
				text: result.text,
				args: result.args.map ((element) => {
					return JSON.stringify(openAllBrackets(element));
				}),
				type: "func" //str(str,var,float),func,funcCommands, commandsList
			}
		}
		
		function isNum(_str) {
			return !isNaN(parseFloat(_str))
		}
		
		if (isNum(result.text)){
			return {
				value: parseFloat(result.text),
				type: "float"
			}
		}
		return {
			text: result.text.trim(),
			type: "str"
		}
	}
}

const result = "";

console.log(result); // Выведет 5
</script>

</body>
</html>
